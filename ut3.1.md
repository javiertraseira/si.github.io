# UT3.1 Clasificaci√≥n, evoluci√≥n y funciones de un SO

## Sistema Operativo

```note
üí° El **Sistema Operativo (SO)** es el software b√°sico de cualquier ordenador o computadora. Este software gestiona los recursos hardware del sistema inform√°tico y proporciona una base para la creaci√≥n y ejecuci√≥n del software de diferentes aplicaciones e interacci√≥n con el usuario.
```

Gracias al Sistema Operativo, el hardware se identifica, se reconoce y el Sistema Inform√°tico empieza a funcionar.

Gracias a los programas y aplicaciones del propio Sistema Operativo (SO), el usuario podr√° realizar determinadas funciones espec√≠ficas.

üìå El **Sistema Operativo** ofrece al usuario la forma de comunicarse con el  ordenador, bien mediante el teclado (**interfaz texto**) , bien mediante  otros dispositivos como el rat√≥n, la pantalla t√°ctil, etc. (**interfaz  gr√°fica**) . El SO es el medio que el usuario utiliza para realizar sus funciones en un sistema inform√°tico u ordenador.

## Clasificaci√≥n de los SO

### Clasificaci√≥n seg√∫n su forma de gesti√≥n  

Se pueden clasificar los SO teniendo en cuenta la gesti√≥n que hacen del software y el hardware, y la forma en que el usuario los puede utilizar:

<img src="media/Clasificacion_SO.png" alt="Clasificacion_SO" style="zoom: 80%;" />

1.  **Sistemas operativos monopuesto** (SOMO): Un solo usuario utiliza a la vez el Sistema Operativo y sus recursos. Se denominan tambi√©n de escritorio.

2.  **Sistemas operativos multiusuario** (SOMU): Permiten que varios usuarios puedan ejecutar a la vez distintos programas y hacer uso de los recursos de una m√°quina al mismo tiempo.

3.  **Sistemas operativos en Red** (SORED): Son aquellos que permite la interconexi√≥n de ordenadores a trav√©s de una Red para poder acceder a servicios, recursos, hardware y software.

4.  **Sistemas operativos distribuidos** (SOD): administran una colecci√≥n de nodos distribuidos que trabajan en red, se comunican entre ellos y comparten recursos.

5.  **Sistemas operativos en tiempo real**: Son sistemas orientados a la respuesta en tiempo real, usados en sistemas cr√≠ticos o cuando el tiempo de respuesta debe ser inmediato.

### Clasificaci√≥n (seg√∫n su forma de procesamiento) 

#### Sistemas Operativos Monopuesto (*SOM*)

   Los Sistemas Operativos Monopuesto (*SOM*) o de escritorio, son aquellos que se instalan para un uso personal o particular o en estaciones de trabajo. Solo un usuario utiliza dicho equipo en un momento determinado y tiene todos los recursos (tanto hardware como software) disponibles para √©l mismo.

   Los usuarios que inician sesi√≥n en estos equipos se denominar√°n usuarios locales y est√°n dados de alta en el mismo equipo que utiliza dicho usuario.

#### Sistemas Operativos Multiusuario (*SOMU*)

   Un Sistema Operativo Multiusuario (*SOMU*) permite acceder de manera simult√°nea a m√°s de un usuario a la vez en un mismo equipo. Por tanto, dicho SO ser√° capaz de proveer de servicio y procesamiento a m√∫ltiples usuarios a la vez. En los SOMU existe un equipo principal. A dicho equipo podr√≠an estar conectados varios terminales, en los que los usuarios realizan su trabajo.
   Existe un solo conjunto de memoria RAM y uno o varios discos duros dentro del mismo equipo, etc. 

   ![](media\somu.png)

   Supongamos que hay cinco usuarios utilizando este sistema y que cada uno ejecuta un programa distinto. El SO deber√° trabajar mucho, ya que tendr√° que ubicar en memoria cinco programas diferentes, e ir ejecutando rotativamente, en principio, instrucciones de cada uno de los programas para que a todos los usuarios se les d√© una respuesta en el menor tiempo posible. La velocidad de respuesta por tanto ser√° inferior a la que dar√≠a un SOMO o un s√≥lo usuario. 
   De esta forma, todo se procesa en un ordenador principal. Primero se ejecutan unas instrucciones del primer programa lanzado por el primer usuario. Acto seguido, este programa se queda detenido para dar un poco de tiempo en la CPU al proceso lanzado por el segundo usuario. 
   Este proceso se repetir√° secuencialmente para dar servicio a todos los programas de todos los usuarios.


#### Sistemas Operativos en Red (*SORED*)

   En los *SORED*, cada usuario tendr√° su proprio ordenador personal con un SO, normalmente monousuario. Cada usuario encender√° su ordenador y establecer√° comunicaci√≥n con el ordenador principal que dispone del SORED. 

   Si parti√©ramos del mismo ejemplo anterior con cuatro usuarios ejecutando cada uno un programa diferente, dispondr√≠amos de cinco CPUs, cinco bloques de memoria independientes, cinco o m√°s dispositivos de almacenamiento, etc.

   ![](media\sored.png)

#### Sistemas Operativos distribuidos (*SOD*)

   Un sistema distribuido se define como una colecci√≥n de equipos inform√°ticos separados f√≠sicamente y conectados entre s√≠ por una red de comunicaciones distribuida; cada m√°quina posee sus componentes de hardware y software de modo que el usuario percibe que existe un solo sistema (no necesita saber qu√© cosas est√°n en qu√© m√°quinas). El usuario accede a los recursos remotos de la misma manera en que accede a recursos locales ya que no percibe que existan varios ordenadores, sino que solo es capaz de ver uno formado por todos los anteriores.

   Una ventaja fundamental de los sistemas distribuidos es que permiten aumentar la potencia del sistema inform√°tico, de modo que 100 ordenadores trabajando en conjunto, permiten formar un √∫nico ordenador que ser√≠a 100 veces m√°s potente.

   ![](media\sod.png)

#### Sistemas Operativos en tiempo real

   Son sistemas en los que los procesos requieren un tiempo de respuesta pr√°cticamente inmediato. Se utilizan en sistema cr√≠ticos, en los que un tiempo de respuesta alto podr√≠a tener serias consecuencias, como sistemas m√©dicos, sistemas aeroespaciales o en centrales energ√©ticas.

  ![](media\so_treal.png)


## Evoluci√≥n hist√≥rica de los SO

En general, podemos hablar de **cuatro generaciones** de sistemas operativos, relacionadas siempre con la evoluci√≥n del hardware:

- Primera generaci√≥n (1945-1955)
- Segunda generaci√≥n (1955-1965)
- Tercera generaci√≥n (1965-1980)
- Cuarta generaci√≥n (1980-actualidad)

Los primeros Sistemas Operativos se denominaban **monol√≠ticos** . La caracter√≠stica fundamental de estos sistemas operativos es que su software b√°sico era pr√°cticamente imposible de modificar una vez creado e instalado en un sistema inform√°tico.

### Primera generaci√≥n (1945-1955)

En esta generaci√≥n los ordenadores utilizaban las **v√°lvulas de vac√≠o** y tableros enchufables. Eran m√°quinas de gran tama√±o de dise√±o √∫nico, programadas en lenguaje de m√°quina puro y complejas interconexiones con sus v√°lvulas.

Llegaron de la mano de dise√±os de Howard Aiken y Jon Von Neumann. Sus operaciones se reduc√≠an a c√°lculos y operaciones matem√°ticas previamente programadas y no pose√≠an sistema operativo como tal (programadas a mano).

![](media\first_generation.png)

### Segunda generaci√≥n (1955-1965)

Se produce la aparici√≥n de los **transistores** lo cual reduce el tama√±o de los ordenadores aumentando su eficiencia. En esta generaci√≥n aparece el **procesamiento por lotes** que constaba de tres fases:

1.  Se introduc√≠an datos en las tarjetas perforadas, cinta magn√©tica o soportes magn√©ticas.
2.  Se transportaba e introduc√≠a el soporte con datos en la computadora para que los procesara devolviendo resultados en otro soporte.
3.  Se lleva ese soporte a otro distinto a la computadora para la generaci√≥n de los resultados.

![](media\second_generation.png)

Estas a√∫n grandes computadoras (sol√≠an ocupar una habitaci√≥n) se usaban primordialmente para c√°lculos cient√≠ficos y de ingenier√≠a, como la resoluci√≥n de ecuaciones diferenciales parciales. Generalmente se programaban en lenguaje FORTRAN o en lenguaje ensamblador.

![](media\second_generation1.png)

Aparecen los primeros sistemas operativos t√≠picos como **FMS** (Fortran Monitor System) e **IBSYS** , el sistema operativo de IBM para la 7094

### Tercera generaci√≥n (1965-1980)

La aparici√≥n de los **circuitos integrados** y de la **multiprogramaci√≥n** supuso toda una revoluci√≥n.

**Multiprogramaci√≥n**

-   Varios trabajos en memoria: cuando uno espera para E/S, otro se puede ejecutar
-   Necesidad de planificaci√≥n y protecci√≥n

**Tiempo compartido (multitarea)**

-   Variante del anterior
-   Cambio r√°pido entre tareas: uso interactivo
-   M√°s complejo

Se redujo el tama√±o y consumo de energ√≠a de los ordenadores gracias a la sustituci√≥n de transistores por **circuitos integrados** , a√∫n m√°s baratos, r√°pidos y fiables.

En esta generaci√≥n destaca el IBM 360 como una m√°quina capaz de realizar cualquier tipo de c√°lculo, con su sistema operativo denominado **OS/360**.

![](media\third_generation.png)

MIT, Bell laboratories y General Electric favorecen el desarrollo de la ‚Äúcomputadora de servicio publico‚Äù as√≠ como el Sistema Operativo para ella **MULTICS** (*Multiplexed information and computing service*)

Se produce un gran crecimiento de las **minicomputadoras**.

>  üîî Ken Thompson, empez√≥ a escribir un nuevo Sistema Operativo conocido como **UNICS**(*Uniplexed information and computing service*) su ortograf√≠a cambi√≥ m√°s tarde por **UNIX**.

![](media\third_generation1.png)

###  Cuarta generaci√≥n (1981-actualidad)

Se produce la aparici√≥n de las **computadoras personales** . Se utilizan complejas t√©cnicas de miniaturizaci√≥n de componentes electr√≥nicos.

Se produce la aparici√≥n de los sistemas operativos modernos que conocemos en la actualidad. Mucho m√°s f√°ciles de utilizar y con la creaci√≥n de interfaces gr√°ficas para una mejor comunicaci√≥n entre m√°quina y usuario.

![](media\forth_generation.png)

Aparici√≥n de los primeros ordenadores personales (PC): Apple II (1978) e IBM PC (1981)

![](media\forth_generation1.png)

La disponibilidad de una cada vez mayor potencia de c√≥mputo, junto con una cada vez mayor potencia gr√°fica, y disponibilidad de discos de almacenamiento masivo en ordenadores personales, dio pie al crecimiento de la importante industria de software que conocemos hoy en d√≠a.

Los sistemas operativos que cobran gran popularidad inicialmente en este per√≠odo (abuelos de los actuales) son **MS-DOS** y **UNIX**:

-   **MS-DOS** de Microsoft fue el primer sistema operativo creado para ordenadores personales en la d√©cada de los 80 y su sucesor fue Windows (inicialmente se ejecutaba encima de MS-DOS). Se trata de un sistema operativo grabado en un disco, de modo que se encontraba permanentemente activo y residente en memoria.

-   **UNIX** dominaba las estaciones de trabajo y servidores en red, as√≠ como m√°quinas de alto rendimiento.

En periodo cronol√≥gico:

-   **MSDOS** fue creado como tal en 1981 despu√©s de que Microsoft comprara *QDOS* modific√°ndolo y haci√©ndolo compatible con *IBM-PC*.

-   En 1984 se lanzaba el primera ordenador Macintosh incluyendo su sistema operativo **MacOS** , cuyas caracter√≠sticas novedosas eran una GUI avanzada, multitarea y rat√≥n.

-   A mediados de los a√±os 80 nace la primera versi√≥n de **Windows** , un mero gestor de ventanas que corre sobre MSDOS, pero no es hasta Windows 95 que se considera un SO separado. La familia sigui√≥ creciendo con Windows 98, NT, Me, 2000, XP, 7, 8 y 10.

-   Respecto a **Linux** nace en 1991 creado por Linus Towards como una versi√≥n mejorada de Unix con licencia **GNU** . Hoy ha evolucionado a un entorno gr√°fico con gestores de ventanas como KDE, GNOME as√≠ como distintas distribuciones que se han ido haciendo famosas (Ubuntu, Debian, Suse, Fedora, Mint‚Ä¶)

-   Entre 2003-2007 surgen los SO para smartphones, a partir del primer iPhone con su SO **iOS** y le sigue Google con su SO Android, basado en Linux, que en la actualidad es el m√°s utilizado en el mundo. Dichos SO se han diversificado a otros dispositivos como tabletas, wereables e IOT.

```note
> üìå En esta generaci√≥n aparecen las distintas variantes conocidas en la actualidad; los sistemas operativos **multiusuario**, los SO en **red**, SO **distribuidos**, SO m√≥viles y SO en **tiempo real**.
```

### Cuadro resumen evoluci√≥n hist√≥rica

Evoluci√≥n hist√≥rica	


| **Generaci√≥n** | **Fecha**       | **Tecnolog√≠a**                           | **Sistemas Operativos**                                |
| -------------- | --------------- | ---------------------------------------- | ------------------------------------------------------ |
| **1¬™**         | 1945-1955       | Tubos de vac√≠o y Tableros                | S.O. no exist√≠a                                        |
| **2¬™**         | 1955-1965       | Transistores y Sistemas por lotes        | FMS e IBSYS de IBM                                     |
| **3¬™**         | 1965-1980       | Circuitos integrados y multiprogramaci√≥n | OS/360, MULTICS, UNICS                                 |
| **4¬™**         | 1980-actualidad | Computadoras Personales                  | MS-DOS, UNIX, WINDOWS, LINUX, SO. de Red, iOS, Android |


## Funciones y arquitectura

```note
El fin fundamental de todo Sistema Operativo es coordinar la utilizaci√≥n que se hace del hardware, dependiendo de los programas o aplicaciones que se est√©n utilizando.
```

Las partes de un SO se estructuran de la siguiente forma **jer√°rquica**:

- Aplicaciones
- Sistema Operativo
- Hardware

```note
üîî La comunicaci√≥n entre los distintos niveles se realiza mediante las llamadas **interfaces**.
```

Un mismo sistema operativo puede trabajar en m√∫ltiples plataformas hardware, por lo que debe poder adaptarse a cada una de ellas.	

Si dejamos al margen los antiguos sistemas operativos monol√≠ticos, actualmente todos los sistemas operativos se organizan en **capas**.

En la actualidad la mayor√≠a de los sistemas operativos son sistemas operativos en red y que trabajan en multitarea.

Estos sistemas operativos pueden funcionar en varias plataformas de hardware gracias a la abstracci√≥n de hardware que se hace (como Linux, Windows, Android)

La **jerarqu√≠a o arquitectura** de los sistemas operativos (SO) que veremos en unidades posteriores puede verse de la siguiente forma ampliada:

![](media\arquitectura_so.jpg)

El sistema Operativo est√° formado por:
- El n√∫cleo o kernel
- Los servicios
- La interfaz de usuarios y aplicaciones

Las **funciones** principales que realiza todo sistema operativo son las siguientes:

1. **Control y ejecuci√≥n de programas**
   Para ello, acepta los trabajos, administra la manera en que se realizan, les asigna los recursos y los
   conserva hasta cerrarse.

2. **Administraci√≥n de hardware, red y perif√©ricos**
   Coordinando y manipulando los dispositivos conectados al ordenador.

3. **Gestionar de ficheros, usuarios y permisos**
   Adjudica los permisos de acceso a los usuarios y a los archivos de un ordenador.

4. **Control de concurrencia y errores**
   Establece prioridades cuando diferentes procesos solicitan un mismo recurso. Gestiona errores de hardware y de datos.

5. **Administraci√≥n de memoria (procesos)**
   Asigna memoria a los procesos y gestiona su uso.

6. **Control de seguridad**
   Proporciona seguridad tanto para los usuarios como para el software y la informaci√≥n almacenada en los sistemas.

## Conceptos SO

Algunos **conceptos clave** usados por los Sistemas Operativos son:

-   **Usuario:** Toda aquella persona que trabaja en el sistema.

-   **Sesi√≥n:** Periodo de tiempo durante el cual un usuario interact√∫a con el sistema.

-   **Programa:** C√≥digo ejecutable. Se trata de un concepto est√°tico.

-   **Proceso:** Programa en ejecuci√≥n y en memoria. Concepto din√°mico.

-   **Fichero:** Unidad l√≥gica de almacenamiento de datos.

-   **Programas del sistema:** Ofrecen un entorno proporcionado por el SO para el desarrollo y ejecuci√≥n de programas.

-   **Interfaz de usuario:** Permite dar instrucciones al SO a trav√©s de diversas formas.

### Servicios y procesos

Para llevar a cabo las funciones descritas anteriormente un Sistema Operativo hace uso de un tipo de aplicaciones especiales denominadas **servicios** (o demonios) funcionando en segundo plano.

```note
üí° Un **servicio**(o demonio) es un tipo de aplicaci√≥n cargado por el sistema operativo que normalmente se ejecutan en **segundo plano** y que permiten llevar a cabo funciones b√°sicas de √©ste.
```

Muchos de los **servicios** (tambi√©n llamados demonios o *daemons *en Linux) son esenciales para el funcionamiento de muchas de las aplicaciones y del propio Sistema Operativo.

Si estos programas, es decir, los servicios, no estuvieran ejecut√°ndose, muchas aplicaciones no funcionar√≠an o algo tan frecuente como el acceso a Internet no ser√≠a posible.

Los **procesos** son otro importante concepto manejado por el sistema operativo, que veremos en la pr√≥ximas unidades en profundidad:

```note
üí° Un **proceso** son el conjunto de instrucciones de un programa que se encuentra en ejecuci√≥n en ese momento (van a procesarse en la CPU)
```

Los procesos son gestionados por el sistema operativo y est√°n formados por:

-   Las **instrucciones** de un programa destinadas a ser ejecutadas por el microprocesador.

-   Su **estado de ejecuci√≥n** en un momento dado, esto es, los valores de los registros de la unidad central de procesamiento para dicho programa.

-   Su **memoria de trabajo**, es decir, la memoria que ha reservado y su contenido.

### Diferencias entre servicios y procesos

- Un **proceso** es la instancia en memoria de un programa ejecutable (un archivo ejecutable **.exe** o binario) que se ejecuta. Una aplicaci√≥n puede tener varios procesos que se ejecutan simult√°neamente. Por ejemplo, algunos navegadores modernos como Google Chrome o Firefox, ejecutan varios procesos a la vez (cada uno de los cuales representa una pesta√±a).

- Un **servicio** es tambi√©n un proceso, pero que se ejecuta en segundo plano y no interact√∫a con nosotros de forma directa como un programa o aplicaci√≥n. En sistemas Windows, los servicios casi siempre se ejecutan como una instancia del proceso **svchost**, tambi√©n identificado como host de servicio (En Linux *systemd*).

## Gesti√≥n de los recursos	

### La Memoria

La parte del sistema operativo que gestiona la memoria se denomina **administrador de memoria**.

```note
üí°  El **administrador de memoria** es una parte cr√≠tica del sistema operativo que se encarga de reservar espacio en la memoria para los nuevos procesos (programas o servicios) y liberarla cuando estos ya no se sigan utilizando as√≠ como el intercambio de datos entre memoria y disco duro.
```

La gesti√≥n de la memoria es importante cuando trabajamos en sistemas operativos multitarea (cualquier SO moderno) ya que trabajan con varios **procesos** a la vez.

![](media\jerarquia_memoria.png)

El **administrador de memoria** proporcionar√° por tanto protecci√≥n y **uso compartido** , es decir, debe proporcionar un espacio de memoria para cada proceso que lo necesite y controlar que ning√∫n otro proceso trabaje en zonas de memoria que no le correspondan produciendo colisiones o inconsistencias
en los datos.

Un error o colisi√≥n de zona de memoria provocar√° un fallo en cascada del SO provocando un cuelgue del sistema.

> Por ejemplo, imagina un sistema de control de temperatura de una habitaci√≥n con dos procesos. Uno de ellos se encarga de leer la temperatura de un sensor; el otro, a partir de dicha temperatura y del valor deseado, controla un generador de fr√≠o/calor. En funci√≥n de estas condiciones, el primer proceso leer√° la temperatura y la depositar√° en una posici√≥n de la memoria a la que el segundo proceso deber√° tener tambi√©n acceso.


### Procesador

```note
üí° Un **proceso** tal y como vimos anteriormente consiste en un programa en ejecuci√≥n gestionado en memoria por el administrador de memoria y que se va a mandar a ejecutar al **procesador** o CPU.
```

Cualquier programa que se est√© ejecutando en un ordenador se convierte en un proceso, ya que desde ese momento el programa, denominado **proceso** , se puede **ejecutar** , se pueda **detener** o se puede **bloquear** , entre otras muchas cosas.

Existen dos tipos de procesos:

-   **Procesos de usuario** : creados por cualquier usuario del sistema y que se ejecutan en modo usuario

-   **Procesos del Sistema Operativo** : creados por el SO o sus servicios y que se ejecutan en modo privilegiado o modo kernel.

![](media\processor_modes.png)

Durante la ejecuci√≥n de un proceso, este **compite** con el resto de los procesos que se est√°n ejecutando de forma concurrente en el sistema por el uso de los recursos hardware (ya sea la CPU o la gr√°fica)

El reparto de los recursos del sistema entre los distintos procesos y su ejecuci√≥n **concurrente** se conoce como **multiprogramaci√≥n** y es gestionada en el **n√∫cleo o kernel** del sistema operativo.

>   Un programa no es un proceso, sino que se convierte en tal en el momento en que se pone en **ejecuci√≥n**. La aplicaci√≥n WordPad, por ejemplo, cuando no se est√° ejecutando no deja de ser un archivo sin m√°s. Y cuando se ejecuta, el archivo *WORDPAD.EXE *sigue estando almacenado donde estaba originalmente. Lo que ocurre es que al ejecutar el programa, las instrucciones necesarias	pasan a la memoria principal. En este momento, cuando al programa est√° en ejecuci√≥n, cuando se convierte en proceso, pero no antes.

Cuantas m√°s instrucciones sea capaz de procesar un procesador, mayor ser√° la velocidad en el sistema, debido a que los procesos esperar√°n menos tiempo a que dicha CPU los atienda y asigne recursos.

####	N√∫cleo o kernel del SO

```note
>  üîî La parte cr√≠tica de un sistema operativo encargada de gestionar los procesos entre s√≠ se denomina **n√∫cleo** o **kernel**.
```

El n√∫cleo o kernel se encarga del manejo de las interrupciones, la asignaci√≥n del trabajo al procesador y el proporcionar una v√≠a de comunicaci√≥n entre los distintos procesos.

El n√∫cleo tiene un subm√≥dulo denominado ‚Äú**planificador**‚Äù el cual se encarga de asignar tiempo del procesador a los procesos, de acuerdo a una cierta pol√≠tica de planificaci√≥n que varia de un sistema operativo a otro. El **administraci√≥n de memoria** visto anteriormente tambi√©n se controla desde el n√∫cleo del SO.

###  Gesti√≥n E/S

```note
> üí° La otra tarea fundamental de cualquier sistema operativo es la gesti√≥n de cualquier unidad perif√©rica (ya sea de *entrada*, *salida*, *mixta* o de *comunicaci√≥n*) que se conecte al ordenador o dispositivo.
```

Recordemos de la unidad anterior, que la comunicaci√≥n de los diferentes perif√©ricos de E/S se lleva a cabo a nivel de hardware a trav√©s de los **chipsets** de la placa base, los cuales comunican dichos componentes con la CPU y la memoria a trav√©s de buses internos.

```note
>  üìå El sistema operativo se encarga de atender todas las particularidades de los dispositivos de E/S como su velocidad de operaci√≥n, una t√©cnica es la salida es el uso de **spoolers,** tambi√©n llamadas colas.
```

Los datos de salida se almacenan de forma temporal en una cola situada en un dispositivo de almacenamiento masivo (**spool**) hasta que el dispositivo perif√©rico requerido se encuentre libre, para evitar que el programa quede retenido porque el perif√©rico no esta listo.

#### Interfaces de usuario

```note
üí° Las **interfaces de usuario** o *shell* son el medio de comunicaci√≥n entre  el usuario, el hardware y el software a trav√©s del SO.
``` 

Las interfaces se clasifican en:

-   **Interfaz tipo texto (CLI)**. Si el SO es de tipo texto, todas las √≥rdenes que el usuario introduzca y las respuestas que el SO d√© se introducir√°n o visualizar√°n mediante cadenas de caracteres.

-   **Interfaz tipo gr√°fico (GUI)**. Hoy en d√≠a, la mayor√≠a de los sistemas operativos utiliza medios de comunicaci√≥n entre m√°quina y ordenador de  tipo gr√°fico.

-   **Interfaz mixta** . Hoy en d√≠a, la mayor√≠a de los sistemas operativos utilizan ambas interfaces para comunicarse con el usuario.

-   **Interfaz natural (NUI)**. Las interfaces naturales utilizan voz, biometr√≠a o realidad virtual/aumentada para una interacci√≥n m√°s natural con la tecnolog√≠a.

![](media\ui_modes.png)

#### Interfaces del programador

Los programadores tienen a su vez acceso a tipos espec√≠ficos de interfaces llamadas API para comunicarse con el SO o con un programa a trav√©s de dicho SO.

Un SDK (Software Development Kit) es un conjunto de herramientas, bibliotecas, documentaci√≥n y ejemplos de c√≥digo que permiten a los desarrolladores crear software o aplicaciones que interact√∫an con un sistema operativo, hardware o plataforma espec√≠fica. Se utiliza como un medio de comunicaci√≥n entre las aplicaciones creadas por el desarrollador y el sistema operativo moderno, facilitando la integraci√≥n con sus caracter√≠sticas y funciones.


## Modos de explotaci√≥n	

![](media\explota_SO.png)


##  Conceptos de servicios y procesos

Los **procesos** son otro importante concepto manejado por el sistema operativo, que veremos en la pr√≥ximas unidades en profundidad:

```note
Un **proceso** son el conjunto de instrucciones de un programa que se encuentra en ejecuci√≥n en ese momento (van a procesarse en la CPU)
```

Los **procesos** son gestionados por el sistema operativo y est√°n formados por:
- Las **instrucciones** de un programa destinadas a ser ejecutadas por el microprocesador.
- Su **estado de ejecuci√≥n** en un momento dado, esto es, los valores de los registros de la unidad central de procesamiento para dicho programa.
- Su **memoria de trabajo**, es decir, la memoria que ha reservado y su contenido.

### Diferencias entre servicios y procesos:

Un **proceso** es la instancia en memoria de un programa ejecutable (un archivo ejecutable .exe o binario) que se ejecuta. Una aplicaci√≥n puede tener varios procesos que se ejecutan simult√°neamente. Por ejemplo, algunos navegadores modernos como Google Chrome o Firefox, ejecutan varios procesos a la vez (cada uno de los cuales representa una pesta√±a).

Un **servicio** es tambi√©n un proceso, pero que se ejecuta en segundo plano y no interact√∫a con nosotros de forma directa como un programa o aplicaci√≥n. En sistemas Windows, los servicios casi siempre se ejecutan como una instancia del proceso *svchost*, tambi√©n identificado como host de servicio (En Linux systemd) 
